package main

import (
	"bytes"
	"crypto/hmac"
	"crypto/sha512"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"net/url"
	"sort"
	"strings"
)

/**
 * JSON encoded API response body parameters.
 */
var responseBody = `{"q" : [{"f" : 1, "d" : 2}], "a" : "something"}`

/**
 * API HTTP method
 */
var requestHttpMethod = `post`

/**
 * Absolute API endpoint URL. In-case if you are passing query parameter this should be in filled with query parameters as well
 *
 * Make sure you configure this endpoint in database, because the endpoint will change for production environment
 *
 */
var absApiUrl = `https://<This will be shared as part of provisioning the partner>/rest/v3/orders`

/**
 * This will be shared as part of provisioning the partner
 */
var clientSecret = `secret string`


/**
 * Sort all query parameters in the request according to the parameter name in ASCII table.
 */
func sortQueryParams() string {
	// urls is used in place of url because it collides with the url package name
	urls := strings.Split(absApiUrl, "?")
	baseUrl := urls[0]
	queryParam := urls[1]

	queryParams := strings.Split(queryParam, "&")

	queryParamMap := make(map[string]string)
	for _, k := range queryParams {
		queryParam := strings.Split(k, "=")
		queryParamMap[queryParam[0]] = queryParam[1]
	}

	keys := make([]string, 0, len(queryParamMap))
	for key := range queryParamMap {
		keys = append(keys, key)
	}

	sort.Strings(keys)

	sortedQueryParams := ""
	for _, key := range keys {
		sortedQueryParams = sortedQueryParams + key + "=" + queryParamMap[key] + "&"
	}

	sortedQueryParams = strings.TrimSuffix(sortedQueryParams, "&")

	encodedQueryParams := url.QueryEscape(sortedQueryParams)

	absApiUrl = url.QueryEscape(baseUrl + "?") + encodedQueryParams

	return absApiUrl

}

/**
 * Concat the (request method(upper case), request host, request URL), encoded response parameters and encoded query parameters using & as the separator.
 */
func getConcatenateBaseString() string {
	baseArray := strings.ToUpper(requestHttpMethod)

	if strings.Index(absApiUrl, "?") >= 0 {
		baseArray = baseArray + "&" + sortQueryParams()
	} else {
		baseArray = baseArray + "&" + url.QueryEscape(absApiUrl)
	}
	if responseBody != "" {
		responseDataMap := make(map[string]interface{})
		responseDataBytes := []byte(responseBody)
		json.Unmarshal(responseDataBytes, &responseDataMap)

		responseDataJsonByte, err := JSONMarshal(responseDataMap)
		if err != nil {
			fmt.Println("Error occurred: " + err.Error())
		}

		// Removing last line generated by JSONMarshal()
		responseDataJson := strings.TrimSuffix(string(responseDataJsonByte), "\n")

		responseDataJson = url.QueryEscape(responseDataJson)

		//Replacing each occurrence of "+" to "%20"
		responseDataJson = strings.Replace(responseDataJson, "+", "%20", -1)
		baseArray = baseArray + "&" + responseDataJson
	}
	return baseArray
}

/**
 * Custom json marshal function used to retain special characters
 */
func JSONMarshal(t interface{}) ([]byte, error) {
	buffer := &bytes.Buffer{}
	encoder := json.NewEncoder(buffer)
	encoder.SetEscapeHTML(false)
	err := encoder.Encode(t)
	return buffer.Bytes(), err
}

func main() {
	h := hmac.New(sha512.New, []byte(clientSecret))
	h.Write([]byte(getConcatenateBaseString()))
	sha := hex.EncodeToString(h.Sum(nil))
	fmt.Println(sha)
}
